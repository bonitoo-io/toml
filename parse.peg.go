package toml

// Code generated by peg -switch -inline parse.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleTOML
	ruleExpression
	rulenewline
	rulenewlineW
	rulenewlineU
	rulews
	rulewsnl
	rulecomment
	rulekeyval
	rulekey
	rulebareKey
	rulequotedKey
	ruleval
	ruletable
	rulestdTable
	rulearrayTable
	ruleinlineTable
	ruleinlineTableKeyValues
	ruletableKey
	ruletableKeyComp
	ruletableKeySep
	ruleinlineTableValSep
	ruleinteger
	ruleint
	rulefloat
	rulefrac
	ruleexp
	rulestring
	rulebasicString
	rulebasicChar
	ruleescaped
	rulebasicUnescaped
	ruleescape
	rulemlBasicString
	rulemlBasicBody
	ruleliteralString
	ruleliteralChar
	rulemlLiteralString
	rulemlLiteralBody
	rulemlLiteralChar
	rulehexdigit
	rulehexQuad
	ruleboolean
	ruledateFullYear
	ruledateMonth
	ruledateMDay
	ruletimeHour
	ruletimeMinute
	ruletimeSecond
	ruletimeSecfrac
	ruletimeNumoffset
	ruletimeOffset
	rulepartialTime
	rulefullDate
	rulefullTime
	ruledatetime
	ruledigit
	ruledigitDual
	ruledigitQuad
	rulearray
	rulearrayValues
	rulearraySep
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
)

var rul3s = [...]string{
	"Unknown",
	"TOML",
	"Expression",
	"newline",
	"newlineW",
	"newlineU",
	"ws",
	"wsnl",
	"comment",
	"keyval",
	"key",
	"bareKey",
	"quotedKey",
	"val",
	"table",
	"stdTable",
	"arrayTable",
	"inlineTable",
	"inlineTableKeyValues",
	"tableKey",
	"tableKeyComp",
	"tableKeySep",
	"inlineTableValSep",
	"integer",
	"int",
	"float",
	"frac",
	"exp",
	"string",
	"basicString",
	"basicChar",
	"escaped",
	"basicUnescaped",
	"escape",
	"mlBasicString",
	"mlBasicBody",
	"literalString",
	"literalChar",
	"mlLiteralString",
	"mlLiteralBody",
	"mlLiteralChar",
	"hexdigit",
	"hexQuad",
	"boolean",
	"dateFullYear",
	"dateMonth",
	"dateMDay",
	"timeHour",
	"timeMinute",
	"timeSecond",
	"timeSecfrac",
	"timeNumoffset",
	"timeOffset",
	"partialTime",
	"fullDate",
	"fullTime",
	"datetime",
	"digit",
	"digitDual",
	"digitQuad",
	"array",
	"arrayValues",
	"arraySep",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[34m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type tomlParser struct {
	toml

	Buffer string
	buffer []rune
	rules  [91]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *tomlParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *tomlParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *tomlParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *tomlParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *tomlParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *tomlParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			_ = buffer
		case ruleAction1:
			p.SetTableString(begin, end)
		case ruleAction2:
			p.AddLineCount((end - begin) / 2)
		case ruleAction3:
			p.AddLineCount(end - begin)
		case ruleAction4:
			p.AddLineCount(1)
		case ruleAction5:
			p.AddKeyValue()
		case ruleAction6:
			p.SetKey(p.buffer, begin, end)
		case ruleAction7:
			p.SetKey(p.buffer, begin, end)
		case ruleAction8:
			p.SetTime(begin, end)
		case ruleAction9:
			p.SetFloat64(begin, end)
		case ruleAction10:
			p.SetInt64(begin, end)
		case ruleAction11:
			p.SetString(begin, end)
		case ruleAction12:
			p.SetBool(begin, end)
		case ruleAction13:
			p.SetArray(begin, end)
		case ruleAction14:
			p.SetTable(p.buffer, begin, end)
		case ruleAction15:
			p.SetArrayTable(p.buffer, begin, end)
		case ruleAction16:
			p.StartInlineTable()
		case ruleAction17:
			p.EndInlineTable()
		case ruleAction18:
			p.AddTableKey()
		case ruleAction19:
			p.SetBasicString(p.buffer, begin, end)
		case ruleAction20:
			p.SetMultilineString()
		case ruleAction21:
			p.AddMultilineBasicBody(p.buffer, begin, end)
		case ruleAction22:
			p.SetLiteralString(p.buffer, begin, end)
		case ruleAction23:
			p.SetMultilineLiteralString(p.buffer, begin, end)
		case ruleAction24:
			p.StartArray()
		case ruleAction25:
			p.AddArrayVal()
		case ruleAction26:
			p.AddArrayVal()

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *tomlParser) Init(options ...func(*tomlParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 TOML <- <(Expression (newline Expression)* wsnl? !. Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleExpression]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l3
					}
					if !_rules[ruleExpression]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				{
					position4, tokenIndex4 := position, tokenIndex
					if !_rules[rulewsnl]() {
						goto l4
					}
					goto l5
				l4:
					position, tokenIndex = position4, tokenIndex4
				}
			l5:
				{
					position6, tokenIndex6 := position, tokenIndex
					if !matchDot() {
						goto l6
					}
					goto l0
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				{
					add(ruleAction0, position)
				}
				add(ruleTOML, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Expression <- <((<(ws table ws comment? (wsnl keyval ws comment?)*)> Action1) / (ws keyval ws comment?) / (ws comment?) / ws)> */
		func() bool {
			position8, tokenIndex8 := position, tokenIndex
			{
				position9 := position
				{
					position10, tokenIndex10 := position, tokenIndex
					{
						position12 := position
						if !_rules[rulews]() {
							goto l11
						}
						{
							position13 := position
							{
								position14, tokenIndex14 := position, tokenIndex
								{
									position16 := position
									if buffer[position] != rune('[') {
										goto l15
									}
									position++
									if !_rules[rulews]() {
										goto l15
									}
									{
										position17 := position
										if !_rules[ruletableKey]() {
											goto l15
										}
										add(rulePegText, position17)
									}
									if !_rules[rulews]() {
										goto l15
									}
									if buffer[position] != rune(']') {
										goto l15
									}
									position++
									{
										add(ruleAction14, position)
									}
									add(rulestdTable, position16)
								}
								goto l14
							l15:
								position, tokenIndex = position14, tokenIndex14
								{
									position19 := position
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if !_rules[rulews]() {
										goto l11
									}
									{
										position20 := position
										if !_rules[ruletableKey]() {
											goto l11
										}
										add(rulePegText, position20)
									}
									if !_rules[rulews]() {
										goto l11
									}
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									{
										add(ruleAction15, position)
									}
									add(rulearrayTable, position19)
								}
							}
						l14:
							add(ruletable, position13)
						}
						if !_rules[rulews]() {
							goto l11
						}
						{
							position22, tokenIndex22 := position, tokenIndex
							if !_rules[rulecomment]() {
								goto l22
							}
							goto l23
						l22:
							position, tokenIndex = position22, tokenIndex22
						}
					l23:
					l24:
						{
							position25, tokenIndex25 := position, tokenIndex
							if !_rules[rulewsnl]() {
								goto l25
							}
							if !_rules[rulekeyval]() {
								goto l25
							}
							if !_rules[rulews]() {
								goto l25
							}
							{
								position26, tokenIndex26 := position, tokenIndex
								if !_rules[rulecomment]() {
									goto l26
								}
								goto l27
							l26:
								position, tokenIndex = position26, tokenIndex26
							}
						l27:
							goto l24
						l25:
							position, tokenIndex = position25, tokenIndex25
						}
						add(rulePegText, position12)
					}
					{
						add(ruleAction1, position)
					}
					goto l10
				l11:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l29
					}
					if !_rules[rulekeyval]() {
						goto l29
					}
					if !_rules[rulews]() {
						goto l29
					}
					{
						position30, tokenIndex30 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l30
						}
						goto l31
					l30:
						position, tokenIndex = position30, tokenIndex30
					}
				l31:
					goto l10
				l29:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l32
					}
					{
						position33, tokenIndex33 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l33
						}
						goto l34
					l33:
						position, tokenIndex = position33, tokenIndex33
					}
				l34:
					goto l10
				l32:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l8
					}
				}
			l10:
				add(ruleExpression, position9)
			}
			return true
		l8:
			position, tokenIndex = position8, tokenIndex8
			return false
		},
		/* 2 newline <- <(newlineW / newlineU)> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				{
					position37, tokenIndex37 := position, tokenIndex
					{
						position39 := position
						{
							position40 := position
							if buffer[position] != rune('\r') {
								goto l38
							}
							position++
							if buffer[position] != rune('\n') {
								goto l38
							}
							position++
						l41:
							{
								position42, tokenIndex42 := position, tokenIndex
								if buffer[position] != rune('\r') {
									goto l42
								}
								position++
								if buffer[position] != rune('\n') {
									goto l42
								}
								position++
								goto l41
							l42:
								position, tokenIndex = position42, tokenIndex42
							}
							add(rulePegText, position40)
						}
						{
							add(ruleAction2, position)
						}
						add(rulenewlineW, position39)
					}
					goto l37
				l38:
					position, tokenIndex = position37, tokenIndex37
					{
						position44 := position
						{
							position45 := position
							{
								position46, tokenIndex46 := position, tokenIndex
								if buffer[position] != rune('\r') {
									goto l47
								}
								position++
							l48:
								{
									position49, tokenIndex49 := position, tokenIndex
									if buffer[position] != rune('\r') {
										goto l49
									}
									position++
									goto l48
								l49:
									position, tokenIndex = position49, tokenIndex49
								}
								goto l46
							l47:
								position, tokenIndex = position46, tokenIndex46
								if buffer[position] != rune('\n') {
									goto l35
								}
								position++
							l50:
								{
									position51, tokenIndex51 := position, tokenIndex
									if buffer[position] != rune('\n') {
										goto l51
									}
									position++
									goto l50
								l51:
									position, tokenIndex = position51, tokenIndex51
								}
							}
						l46:
							add(rulePegText, position45)
						}
						{
							add(ruleAction3, position)
						}
						add(rulenewlineU, position44)
					}
				}
			l37:
				add(rulenewline, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 3 newlineW <- <(<('\r' '\n')+> Action2)> */
		nil,
		/* 4 newlineU <- <(<('\r'+ / '\n'+)> Action3)> */
		nil,
		/* 5 ws <- <(' '* / '\t'*)> */
		func() bool {
			{
				position56 := position
				{
					position57, tokenIndex57 := position, tokenIndex
				l59:
					{
						position60, tokenIndex60 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l60
						}
						position++
						goto l59
					l60:
						position, tokenIndex = position60, tokenIndex60
					}
					goto l57

					position, tokenIndex = position57, tokenIndex57
				l61:
					{
						position62, tokenIndex62 := position, tokenIndex
						if buffer[position] != rune('\t') {
							goto l62
						}
						position++
						goto l61
					l62:
						position, tokenIndex = position62, tokenIndex62
					}
				}
			l57:
				add(rulews, position56)
			}
			return true
		},
		/* 6 wsnl <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') (<('\n' / ('\r' '\n'))> Action4)))*> */
		func() bool {
			{
				position64 := position
			l65:
				{
					position66, tokenIndex66 := position, tokenIndex
					{
						switch buffer[position] {
						case '\t':
							if buffer[position] != rune('\t') {
								goto l66
							}
							position++
						case ' ':
							if buffer[position] != rune(' ') {
								goto l66
							}
							position++
						default:
							{
								position68 := position
								{
									position69, tokenIndex69 := position, tokenIndex
									if buffer[position] != rune('\n') {
										goto l70
									}
									position++
									goto l69
								l70:
									position, tokenIndex = position69, tokenIndex69
									if buffer[position] != rune('\r') {
										goto l66
									}
									position++
									if buffer[position] != rune('\n') {
										goto l66
									}
									position++
								}
							l69:
								add(rulePegText, position68)
							}
							{
								add(ruleAction4, position)
							}
						}
					}

					goto l65
				l66:
					position, tokenIndex = position66, tokenIndex66
				}
				add(rulewsnl, position64)
			}
			return true
		},
		/* 7 comment <- <('#' <('\t' / [ -\U0010ffff])*>)> */
		func() bool {
			position72, tokenIndex72 := position, tokenIndex
			{
				position73 := position
				if buffer[position] != rune('#') {
					goto l72
				}
				position++
				{
					position74 := position
				l75:
					{
						position76, tokenIndex76 := position, tokenIndex
						{
							position77, tokenIndex77 := position, tokenIndex
							if buffer[position] != rune('\t') {
								goto l78
							}
							position++
							goto l77
						l78:
							position, tokenIndex = position77, tokenIndex77
							if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
								goto l76
							}
							position++
						}
					l77:
						goto l75
					l76:
						position, tokenIndex = position76, tokenIndex76
					}
					add(rulePegText, position74)
				}
				add(rulecomment, position73)
			}
			return true
		l72:
			position, tokenIndex = position72, tokenIndex72
			return false
		},
		/* 8 keyval <- <(key ws '=' ws val Action5)> */
		func() bool {
			position79, tokenIndex79 := position, tokenIndex
			{
				position80 := position
				if !_rules[rulekey]() {
					goto l79
				}
				if !_rules[rulews]() {
					goto l79
				}
				if buffer[position] != rune('=') {
					goto l79
				}
				position++
				if !_rules[rulews]() {
					goto l79
				}
				if !_rules[ruleval]() {
					goto l79
				}
				{
					add(ruleAction5, position)
				}
				add(rulekeyval, position80)
			}
			return true
		l79:
			position, tokenIndex = position79, tokenIndex79
			return false
		},
		/* 9 key <- <(bareKey / quotedKey)> */
		func() bool {
			position82, tokenIndex82 := position, tokenIndex
			{
				position83 := position
				{
					position84, tokenIndex84 := position, tokenIndex
					{
						position86 := position
						{
							position87 := position
							{
								switch buffer[position] {
								case '_':
									if buffer[position] != rune('_') {
										goto l85
									}
									position++
								case '-':
									if buffer[position] != rune('-') {
										goto l85
									}
									position++
								case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
									if c := buffer[position]; c < rune('a') || c > rune('z') {
										goto l85
									}
									position++
								case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
									if c := buffer[position]; c < rune('0') || c > rune('9') {
										goto l85
									}
									position++
								default:
									if c := buffer[position]; c < rune('A') || c > rune('Z') {
										goto l85
									}
									position++
								}
							}

						l88:
							{
								position89, tokenIndex89 := position, tokenIndex
								{
									switch buffer[position] {
									case '_':
										if buffer[position] != rune('_') {
											goto l89
										}
										position++
									case '-':
										if buffer[position] != rune('-') {
											goto l89
										}
										position++
									case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
										if c := buffer[position]; c < rune('a') || c > rune('z') {
											goto l89
										}
										position++
									case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l89
										}
										position++
									default:
										if c := buffer[position]; c < rune('A') || c > rune('Z') {
											goto l89
										}
										position++
									}
								}

								goto l88
							l89:
								position, tokenIndex = position89, tokenIndex89
							}
							add(rulePegText, position87)
						}
						{
							add(ruleAction6, position)
						}
						add(rulebareKey, position86)
					}
					goto l84
				l85:
					position, tokenIndex = position84, tokenIndex84
					{
						position93 := position
						{
							position94 := position
							if buffer[position] != rune('"') {
								goto l82
							}
							position++
						l95:
							{
								position96, tokenIndex96 := position, tokenIndex
								if !_rules[rulebasicChar]() {
									goto l96
								}
								goto l95
							l96:
								position, tokenIndex = position96, tokenIndex96
							}
							if buffer[position] != rune('"') {
								goto l82
							}
							position++
							add(rulePegText, position94)
						}
						{
							add(ruleAction7, position)
						}
						add(rulequotedKey, position93)
					}
				}
			l84:
				add(rulekey, position83)
			}
			return true
		l82:
			position, tokenIndex = position82, tokenIndex82
			return false
		},
		/* 10 bareKey <- <(<((&('_') '_') | (&('-') '-') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]))+> Action6)> */
		nil,
		/* 11 quotedKey <- <(<('"' basicChar* '"')> Action7)> */
		nil,
		/* 12 val <- <((<datetime> Action8) / (<float> Action9) / ((&('{') inlineTable) | (&('[') (<array> Action13)) | (&('f' | 't') (<boolean> Action12)) | (&('"' | '\'') (<string> Action11)) | (&('+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') (<integer> Action10))))> */
		func() bool {
			position100, tokenIndex100 := position, tokenIndex
			{
				position101 := position
				{
					position102, tokenIndex102 := position, tokenIndex
					{
						position104 := position
						{
							position105 := position
							{
								position106, tokenIndex106 := position, tokenIndex
								{
									position108 := position
									{
										position109 := position
										{
											position110 := position
											if !_rules[ruledigitDual]() {
												goto l107
											}
											if !_rules[ruledigitDual]() {
												goto l107
											}
											add(ruledigitQuad, position110)
										}
										add(ruledateFullYear, position109)
									}
									if buffer[position] != rune('-') {
										goto l107
									}
									position++
									{
										position111 := position
										if !_rules[ruledigitDual]() {
											goto l107
										}
										add(ruledateMonth, position111)
									}
									if buffer[position] != rune('-') {
										goto l107
									}
									position++
									{
										position112 := position
										if !_rules[ruledigitDual]() {
											goto l107
										}
										add(ruledateMDay, position112)
									}
									add(rulefullDate, position108)
								}
								{
									position113, tokenIndex113 := position, tokenIndex
									if buffer[position] != rune('T') {
										goto l113
									}
									position++
									{
										position115 := position
										if !_rules[rulepartialTime]() {
											goto l113
										}
										{
											position116, tokenIndex116 := position, tokenIndex
											{
												position118 := position
												{
													position119, tokenIndex119 := position, tokenIndex
													if buffer[position] != rune('Z') {
														goto l120
													}
													position++
													goto l119
												l120:
													position, tokenIndex = position119, tokenIndex119
													{
														position121 := position
														{
															position122, tokenIndex122 := position, tokenIndex
															if buffer[position] != rune('-') {
																goto l123
															}
															position++
															goto l122
														l123:
															position, tokenIndex = position122, tokenIndex122
															if buffer[position] != rune('+') {
																goto l116
															}
															position++
														}
													l122:
														if !_rules[ruletimeHour]() {
															goto l116
														}
														if buffer[position] != rune(':') {
															goto l116
														}
														position++
														if !_rules[ruletimeMinute]() {
															goto l116
														}
														add(ruletimeNumoffset, position121)
													}
												}
											l119:
												add(ruletimeOffset, position118)
											}
											goto l117
										l116:
											position, tokenIndex = position116, tokenIndex116
										}
									l117:
										add(rulefullTime, position115)
									}
									goto l114
								l113:
									position, tokenIndex = position113, tokenIndex113
								}
							l114:
								goto l106
							l107:
								position, tokenIndex = position106, tokenIndex106
								if !_rules[rulepartialTime]() {
									goto l103
								}
							}
						l106:
							add(ruledatetime, position105)
						}
						add(rulePegText, position104)
					}
					{
						add(ruleAction8, position)
					}
					goto l102
				l103:
					position, tokenIndex = position102, tokenIndex102
					{
						position126 := position
						{
							position127 := position
							if !_rules[ruleinteger]() {
								goto l125
							}
							{
								position128, tokenIndex128 := position, tokenIndex
								if !_rules[rulefrac]() {
									goto l129
								}
								{
									position130, tokenIndex130 := position, tokenIndex
									if !_rules[ruleexp]() {
										goto l130
									}
									goto l131
								l130:
									position, tokenIndex = position130, tokenIndex130
								}
							l131:
								goto l128
							l129:
								position, tokenIndex = position128, tokenIndex128
								{
									position132, tokenIndex132 := position, tokenIndex
									if !_rules[rulefrac]() {
										goto l132
									}
									goto l133
								l132:
									position, tokenIndex = position132, tokenIndex132
								}
							l133:
								if !_rules[ruleexp]() {
									goto l125
								}
							}
						l128:
							add(rulefloat, position127)
						}
						add(rulePegText, position126)
					}
					{
						add(ruleAction9, position)
					}
					goto l102
				l125:
					position, tokenIndex = position102, tokenIndex102
					{
						switch buffer[position] {
						case '{':
							{
								position136 := position
								if buffer[position] != rune('{') {
									goto l100
								}
								position++
								{
									add(ruleAction16, position)
								}
								if !_rules[rulews]() {
									goto l100
								}
								{
									position138 := position
								l139:
									{
										position140, tokenIndex140 := position, tokenIndex
										if !_rules[rulekeyval]() {
											goto l140
										}
										{
											position141, tokenIndex141 := position, tokenIndex
											{
												position143 := position
												if !_rules[rulews]() {
													goto l141
												}
												if buffer[position] != rune(',') {
													goto l141
												}
												position++
												if !_rules[rulews]() {
													goto l141
												}
												add(ruleinlineTableValSep, position143)
											}
											goto l142
										l141:
											position, tokenIndex = position141, tokenIndex141
										}
									l142:
										goto l139
									l140:
										position, tokenIndex = position140, tokenIndex140
									}
									add(ruleinlineTableKeyValues, position138)
								}
								if !_rules[rulews]() {
									goto l100
								}
								if buffer[position] != rune('}') {
									goto l100
								}
								position++
								{
									add(ruleAction17, position)
								}
								add(ruleinlineTable, position136)
							}
						case '[':
							{
								position145 := position
								{
									position146 := position
									if buffer[position] != rune('[') {
										goto l100
									}
									position++
									{
										add(ruleAction24, position)
									}
									if !_rules[rulewsnl]() {
										goto l100
									}
									{
										position148, tokenIndex148 := position, tokenIndex
										{
											position150 := position
											if !_rules[ruleval]() {
												goto l148
											}
											{
												add(ruleAction25, position)
											}
										l152:
											{
												position153, tokenIndex153 := position, tokenIndex
												if !_rules[rulewsnl]() {
													goto l153
												}
												{
													position154, tokenIndex154 := position, tokenIndex
													if !_rules[rulecomment]() {
														goto l154
													}
													goto l155
												l154:
													position, tokenIndex = position154, tokenIndex154
												}
											l155:
												if !_rules[rulewsnl]() {
													goto l153
												}
												if !_rules[rulearraySep]() {
													goto l153
												}
												if !_rules[rulewsnl]() {
													goto l153
												}
												{
													position156, tokenIndex156 := position, tokenIndex
													if !_rules[rulecomment]() {
														goto l156
													}
													goto l157
												l156:
													position, tokenIndex = position156, tokenIndex156
												}
											l157:
												if !_rules[rulewsnl]() {
													goto l153
												}
												if !_rules[ruleval]() {
													goto l153
												}
												{
													add(ruleAction26, position)
												}
												goto l152
											l153:
												position, tokenIndex = position153, tokenIndex153
											}
											if !_rules[rulewsnl]() {
												goto l148
											}
											{
												position159, tokenIndex159 := position, tokenIndex
												if !_rules[rulearraySep]() {
													goto l159
												}
												goto l160
											l159:
												position, tokenIndex = position159, tokenIndex159
											}
										l160:
											if !_rules[rulewsnl]() {
												goto l148
											}
											{
												position161, tokenIndex161 := position, tokenIndex
												if !_rules[rulecomment]() {
													goto l161
												}
												goto l162
											l161:
												position, tokenIndex = position161, tokenIndex161
											}
										l162:
											add(rulearrayValues, position150)
										}
										goto l149
									l148:
										position, tokenIndex = position148, tokenIndex148
									}
								l149:
									if !_rules[rulewsnl]() {
										goto l100
									}
									if buffer[position] != rune(']') {
										goto l100
									}
									position++
									add(rulearray, position146)
								}
								add(rulePegText, position145)
							}
							{
								add(ruleAction13, position)
							}
						case 'f', 't':
							{
								position164 := position
								{
									position165 := position
									{
										position166, tokenIndex166 := position, tokenIndex
										if buffer[position] != rune('t') {
											goto l167
										}
										position++
										if buffer[position] != rune('r') {
											goto l167
										}
										position++
										if buffer[position] != rune('u') {
											goto l167
										}
										position++
										if buffer[position] != rune('e') {
											goto l167
										}
										position++
										goto l166
									l167:
										position, tokenIndex = position166, tokenIndex166
										if buffer[position] != rune('f') {
											goto l100
										}
										position++
										if buffer[position] != rune('a') {
											goto l100
										}
										position++
										if buffer[position] != rune('l') {
											goto l100
										}
										position++
										if buffer[position] != rune('s') {
											goto l100
										}
										position++
										if buffer[position] != rune('e') {
											goto l100
										}
										position++
									}
								l166:
									add(ruleboolean, position165)
								}
								add(rulePegText, position164)
							}
							{
								add(ruleAction12, position)
							}
						case '"', '\'':
							{
								position169 := position
								{
									position170 := position
									{
										position171, tokenIndex171 := position, tokenIndex
										{
											position173 := position
											if buffer[position] != rune('\'') {
												goto l172
											}
											position++
											if buffer[position] != rune('\'') {
												goto l172
											}
											position++
											if buffer[position] != rune('\'') {
												goto l172
											}
											position++
											{
												position174 := position
												{
													position175 := position
												l176:
													{
														position177, tokenIndex177 := position, tokenIndex
														{
															position178, tokenIndex178 := position, tokenIndex
															if buffer[position] != rune('\'') {
																goto l178
															}
															position++
															if buffer[position] != rune('\'') {
																goto l178
															}
															position++
															if buffer[position] != rune('\'') {
																goto l178
															}
															position++
															goto l177
														l178:
															position, tokenIndex = position178, tokenIndex178
														}
														{
															position179, tokenIndex179 := position, tokenIndex
															{
																position181 := position
																{
																	position182, tokenIndex182 := position, tokenIndex
																	if buffer[position] != rune('\t') {
																		goto l183
																	}
																	position++
																	goto l182
																l183:
																	position, tokenIndex = position182, tokenIndex182
																	if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
																		goto l180
																	}
																	position++
																}
															l182:
																add(rulemlLiteralChar, position181)
															}
															goto l179
														l180:
															position, tokenIndex = position179, tokenIndex179
															if !_rules[rulenewline]() {
																goto l177
															}
														}
													l179:
														goto l176
													l177:
														position, tokenIndex = position177, tokenIndex177
													}
													add(rulemlLiteralBody, position175)
												}
												add(rulePegText, position174)
											}
											if buffer[position] != rune('\'') {
												goto l172
											}
											position++
											if buffer[position] != rune('\'') {
												goto l172
											}
											position++
											if buffer[position] != rune('\'') {
												goto l172
											}
											position++
											{
												add(ruleAction23, position)
											}
											add(rulemlLiteralString, position173)
										}
										goto l171
									l172:
										position, tokenIndex = position171, tokenIndex171
										{
											position186 := position
											if buffer[position] != rune('\'') {
												goto l185
											}
											position++
											{
												position187 := position
											l188:
												{
													position189, tokenIndex189 := position, tokenIndex
													{
														position190 := position
														{
															switch buffer[position] {
															case '\t':
																if buffer[position] != rune('\t') {
																	goto l189
																}
																position++
															case ' ', '!', '"', '#', '$', '%', '&':
																if c := buffer[position]; c < rune(' ') || c > rune('&') {
																	goto l189
																}
																position++
															default:
																if c := buffer[position]; c < rune('(') || c > rune('\U0010ffff') {
																	goto l189
																}
																position++
															}
														}

														add(ruleliteralChar, position190)
													}
													goto l188
												l189:
													position, tokenIndex = position189, tokenIndex189
												}
												add(rulePegText, position187)
											}
											if buffer[position] != rune('\'') {
												goto l185
											}
											position++
											{
												add(ruleAction22, position)
											}
											add(ruleliteralString, position186)
										}
										goto l171
									l185:
										position, tokenIndex = position171, tokenIndex171
										{
											position194 := position
											if buffer[position] != rune('"') {
												goto l193
											}
											position++
											if buffer[position] != rune('"') {
												goto l193
											}
											position++
											if buffer[position] != rune('"') {
												goto l193
											}
											position++
											{
												position195 := position
											l196:
												{
													position197, tokenIndex197 := position, tokenIndex
													{
														position198, tokenIndex198 := position, tokenIndex
														{
															position200 := position
															{
																position201, tokenIndex201 := position, tokenIndex
																if !_rules[rulebasicChar]() {
																	goto l202
																}
																goto l201
															l202:
																position, tokenIndex = position201, tokenIndex201
																if !_rules[rulenewline]() {
																	goto l199
																}
															}
														l201:
															add(rulePegText, position200)
														}
														{
															add(ruleAction21, position)
														}
														goto l198
													l199:
														position, tokenIndex = position198, tokenIndex198
														if !_rules[ruleescape]() {
															goto l197
														}
														if !_rules[rulenewline]() {
															goto l197
														}
														if !_rules[rulewsnl]() {
															goto l197
														}
													}
												l198:
													goto l196
												l197:
													position, tokenIndex = position197, tokenIndex197
												}
												add(rulemlBasicBody, position195)
											}
											if buffer[position] != rune('"') {
												goto l193
											}
											position++
											if buffer[position] != rune('"') {
												goto l193
											}
											position++
											if buffer[position] != rune('"') {
												goto l193
											}
											position++
											{
												add(ruleAction20, position)
											}
											add(rulemlBasicString, position194)
										}
										goto l171
									l193:
										position, tokenIndex = position171, tokenIndex171
										{
											position205 := position
											{
												position206 := position
												if buffer[position] != rune('"') {
													goto l100
												}
												position++
											l207:
												{
													position208, tokenIndex208 := position, tokenIndex
													if !_rules[rulebasicChar]() {
														goto l208
													}
													goto l207
												l208:
													position, tokenIndex = position208, tokenIndex208
												}
												if buffer[position] != rune('"') {
													goto l100
												}
												position++
												add(rulePegText, position206)
											}
											{
												add(ruleAction19, position)
											}
											add(rulebasicString, position205)
										}
									}
								l171:
									add(rulestring, position170)
								}
								add(rulePegText, position169)
							}
							{
								add(ruleAction11, position)
							}
						default:
							{
								position211 := position
								if !_rules[ruleinteger]() {
									goto l100
								}
								add(rulePegText, position211)
							}
							{
								add(ruleAction10, position)
							}
						}
					}

				}
			l102:
				add(ruleval, position101)
			}
			return true
		l100:
			position, tokenIndex = position100, tokenIndex100
			return false
		},
		/* 13 table <- <(stdTable / arrayTable)> */
		nil,
		/* 14 stdTable <- <('[' ws <tableKey> ws ']' Action14)> */
		nil,
		/* 15 arrayTable <- <('[' '[' ws <tableKey> ws (']' ']') Action15)> */
		nil,
		/* 16 inlineTable <- <('{' Action16 ws inlineTableKeyValues ws '}' Action17)> */
		nil,
		/* 17 inlineTableKeyValues <- <(keyval inlineTableValSep?)*> */
		nil,
		/* 18 tableKey <- <(tableKeyComp (tableKeySep tableKeyComp)*)> */
		func() bool {
			position218, tokenIndex218 := position, tokenIndex
			{
				position219 := position
				if !_rules[ruletableKeyComp]() {
					goto l218
				}
			l220:
				{
					position221, tokenIndex221 := position, tokenIndex
					{
						position222 := position
						if !_rules[rulews]() {
							goto l221
						}
						if buffer[position] != rune('.') {
							goto l221
						}
						position++
						if !_rules[rulews]() {
							goto l221
						}
						add(ruletableKeySep, position222)
					}
					if !_rules[ruletableKeyComp]() {
						goto l221
					}
					goto l220
				l221:
					position, tokenIndex = position221, tokenIndex221
				}
				add(ruletableKey, position219)
			}
			return true
		l218:
			position, tokenIndex = position218, tokenIndex218
			return false
		},
		/* 19 tableKeyComp <- <(key Action18)> */
		func() bool {
			position223, tokenIndex223 := position, tokenIndex
			{
				position224 := position
				if !_rules[rulekey]() {
					goto l223
				}
				{
					add(ruleAction18, position)
				}
				add(ruletableKeyComp, position224)
			}
			return true
		l223:
			position, tokenIndex = position223, tokenIndex223
			return false
		},
		/* 20 tableKeySep <- <(ws '.' ws)> */
		nil,
		/* 21 inlineTableValSep <- <(ws ',' ws)> */
		nil,
		/* 22 integer <- <(('-' / '+')? int)> */
		func() bool {
			position228, tokenIndex228 := position, tokenIndex
			{
				position229 := position
				{
					position230, tokenIndex230 := position, tokenIndex
					{
						position232, tokenIndex232 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l233
						}
						position++
						goto l232
					l233:
						position, tokenIndex = position232, tokenIndex232
						if buffer[position] != rune('+') {
							goto l230
						}
						position++
					}
				l232:
					goto l231
				l230:
					position, tokenIndex = position230, tokenIndex230
				}
			l231:
				{
					position234 := position
					{
						position235, tokenIndex235 := position, tokenIndex
						if c := buffer[position]; c < rune('1') || c > rune('9') {
							goto l236
						}
						position++
						{
							position239, tokenIndex239 := position, tokenIndex
							if !_rules[ruledigit]() {
								goto l240
							}
							goto l239
						l240:
							position, tokenIndex = position239, tokenIndex239
							if buffer[position] != rune('_') {
								goto l236
							}
							position++
							if !_rules[ruledigit]() {
								goto l236
							}
						}
					l239:
					l237:
						{
							position238, tokenIndex238 := position, tokenIndex
							{
								position241, tokenIndex241 := position, tokenIndex
								if !_rules[ruledigit]() {
									goto l242
								}
								goto l241
							l242:
								position, tokenIndex = position241, tokenIndex241
								if buffer[position] != rune('_') {
									goto l238
								}
								position++
								if !_rules[ruledigit]() {
									goto l238
								}
							}
						l241:
							goto l237
						l238:
							position, tokenIndex = position238, tokenIndex238
						}
						goto l235
					l236:
						position, tokenIndex = position235, tokenIndex235
						if !_rules[ruledigit]() {
							goto l228
						}
					}
				l235:
					add(ruleint, position234)
				}
				add(ruleinteger, position229)
			}
			return true
		l228:
			position, tokenIndex = position228, tokenIndex228
			return false
		},
		/* 23 int <- <(([1-9] (digit / ('_' digit))+) / digit)> */
		nil,
		/* 24 float <- <(integer ((frac exp?) / (frac? exp)))> */
		nil,
		/* 25 frac <- <('.' digit (digit / ('_' digit))*)> */
		func() bool {
			position245, tokenIndex245 := position, tokenIndex
			{
				position246 := position
				if buffer[position] != rune('.') {
					goto l245
				}
				position++
				if !_rules[ruledigit]() {
					goto l245
				}
			l247:
				{
					position248, tokenIndex248 := position, tokenIndex
					{
						position249, tokenIndex249 := position, tokenIndex
						if !_rules[ruledigit]() {
							goto l250
						}
						goto l249
					l250:
						position, tokenIndex = position249, tokenIndex249
						if buffer[position] != rune('_') {
							goto l248
						}
						position++
						if !_rules[ruledigit]() {
							goto l248
						}
					}
				l249:
					goto l247
				l248:
					position, tokenIndex = position248, tokenIndex248
				}
				add(rulefrac, position246)
			}
			return true
		l245:
			position, tokenIndex = position245, tokenIndex245
			return false
		},
		/* 26 exp <- <(('e' / 'E') ('-' / '+')? digit (digit / ('_' digit))*)> */
		func() bool {
			position251, tokenIndex251 := position, tokenIndex
			{
				position252 := position
				{
					position253, tokenIndex253 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l254
					}
					position++
					goto l253
				l254:
					position, tokenIndex = position253, tokenIndex253
					if buffer[position] != rune('E') {
						goto l251
					}
					position++
				}
			l253:
				{
					position255, tokenIndex255 := position, tokenIndex
					{
						position257, tokenIndex257 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l258
						}
						position++
						goto l257
					l258:
						position, tokenIndex = position257, tokenIndex257
						if buffer[position] != rune('+') {
							goto l255
						}
						position++
					}
				l257:
					goto l256
				l255:
					position, tokenIndex = position255, tokenIndex255
				}
			l256:
				if !_rules[ruledigit]() {
					goto l251
				}
			l259:
				{
					position260, tokenIndex260 := position, tokenIndex
					{
						position261, tokenIndex261 := position, tokenIndex
						if !_rules[ruledigit]() {
							goto l262
						}
						goto l261
					l262:
						position, tokenIndex = position261, tokenIndex261
						if buffer[position] != rune('_') {
							goto l260
						}
						position++
						if !_rules[ruledigit]() {
							goto l260
						}
					}
				l261:
					goto l259
				l260:
					position, tokenIndex = position260, tokenIndex260
				}
				add(ruleexp, position252)
			}
			return true
		l251:
			position, tokenIndex = position251, tokenIndex251
			return false
		},
		/* 27 string <- <(mlLiteralString / literalString / mlBasicString / basicString)> */
		nil,
		/* 28 basicString <- <(<('"' basicChar* '"')> Action19)> */
		nil,
		/* 29 basicChar <- <(basicUnescaped / escaped)> */
		func() bool {
			position265, tokenIndex265 := position, tokenIndex
			{
				position266 := position
				{
					position267, tokenIndex267 := position, tokenIndex
					{
						position269 := position
						{
							switch buffer[position] {
							case ' ', '!':
								if c := buffer[position]; c < rune(' ') || c > rune('!') {
									goto l268
								}
								position++
							case '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[':
								if c := buffer[position]; c < rune('#') || c > rune('[') {
									goto l268
								}
								position++
							default:
								if c := buffer[position]; c < rune(']') || c > rune('\U0010ffff') {
									goto l268
								}
								position++
							}
						}

						add(rulebasicUnescaped, position269)
					}
					goto l267
				l268:
					position, tokenIndex = position267, tokenIndex267
					{
						position271 := position
						if !_rules[ruleescape]() {
							goto l265
						}
						{
							switch buffer[position] {
							case 'U':
								if buffer[position] != rune('U') {
									goto l265
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l265
								}
								if !_rules[rulehexQuad]() {
									goto l265
								}
							case 'u':
								if buffer[position] != rune('u') {
									goto l265
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l265
								}
							case '\\':
								if buffer[position] != rune('\\') {
									goto l265
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l265
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l265
								}
								position++
							case 'r':
								if buffer[position] != rune('r') {
									goto l265
								}
								position++
							case 'f':
								if buffer[position] != rune('f') {
									goto l265
								}
								position++
							case 'n':
								if buffer[position] != rune('n') {
									goto l265
								}
								position++
							case 't':
								if buffer[position] != rune('t') {
									goto l265
								}
								position++
							default:
								if buffer[position] != rune('b') {
									goto l265
								}
								position++
							}
						}

						add(ruleescaped, position271)
					}
				}
			l267:
				add(rulebasicChar, position266)
			}
			return true
		l265:
			position, tokenIndex = position265, tokenIndex265
			return false
		},
		/* 30 escaped <- <(escape ((&('U') ('U' hexQuad hexQuad)) | (&('u') ('u' hexQuad)) | (&('\\') '\\') | (&('/') '/') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		nil,
		/* 31 basicUnescaped <- <((&(' ' | '!') [ -!]) | (&('#' | '$' | '%' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[') [#-[]) | (&(']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '¡' | '¢' | '£' | '¤' | '¥' | '¦' | '§' | '¨' | '©' | 'ª' | '«' | '¬' | '\u00ad' | '®' | '¯' | '°' | '±' | '²' | '³' | '´' | 'µ' | '¶' | '·' | '¸' | '¹' | 'º' | '»' | '¼' | '½' | '¾' | '¿' | 'À' | 'Á' | 'Â' | 'Ã' | 'Ä' | 'Å' | 'Æ' | 'Ç' | 'È' | 'É' | 'Ê' | 'Ë' | 'Ì' | 'Í' | 'Î' | 'Ï' | 'Ð' | 'Ñ' | 'Ò' | 'Ó' | 'Ô' | 'Õ' | 'Ö' | '×' | 'Ø' | 'Ù' | 'Ú' | 'Û' | 'Ü' | 'Ý' | 'Þ' | 'ß' | 'à' | 'á' | 'â' | 'ã' | 'ä' | 'å' | 'æ' | 'ç' | 'è' | 'é' | 'ê' | 'ë' | 'ì' | 'í' | 'î' | 'ï' | 'ð' | 'ñ' | 'ò' | 'ó' | 'ô' | 'õ' | 'ö' | '÷' | 'ø' | 'ù' | 'ú' | 'û' | 'ü' | 'ý' | 'þ' | 'ÿ') []-\U0010ffff]))> */
		nil,
		/* 32 escape <- <'\\'> */
		func() bool {
			position275, tokenIndex275 := position, tokenIndex
			{
				position276 := position
				if buffer[position] != rune('\\') {
					goto l275
				}
				position++
				add(ruleescape, position276)
			}
			return true
		l275:
			position, tokenIndex = position275, tokenIndex275
			return false
		},
		/* 33 mlBasicString <- <('"' '"' '"' mlBasicBody ('"' '"' '"') Action20)> */
		nil,
		/* 34 mlBasicBody <- <((<(basicChar / newline)> Action21) / (escape newline wsnl))*> */
		nil,
		/* 35 literalString <- <('\'' <literalChar*> '\'' Action22)> */
		nil,
		/* 36 literalChar <- <((&('\t') '\t') | (&(' ' | '!' | '"' | '#' | '$' | '%' | '&') [ -&]) | (&('(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[' | '\\' | ']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '¡' | '¢' | '£' | '¤' | '¥' | '¦' | '§' | '¨' | '©' | 'ª' | '«' | '¬' | '\u00ad' | '®' | '¯' | '°' | '±' | '²' | '³' | '´' | 'µ' | '¶' | '·' | '¸' | '¹' | 'º' | '»' | '¼' | '½' | '¾' | '¿' | 'À' | 'Á' | 'Â' | 'Ã' | 'Ä' | 'Å' | 'Æ' | 'Ç' | 'È' | 'É' | 'Ê' | 'Ë' | 'Ì' | 'Í' | 'Î' | 'Ï' | 'Ð' | 'Ñ' | 'Ò' | 'Ó' | 'Ô' | 'Õ' | 'Ö' | '×' | 'Ø' | 'Ù' | 'Ú' | 'Û' | 'Ü' | 'Ý' | 'Þ' | 'ß' | 'à' | 'á' | 'â' | 'ã' | 'ä' | 'å' | 'æ' | 'ç' | 'è' | 'é' | 'ê' | 'ë' | 'ì' | 'í' | 'î' | 'ï' | 'ð' | 'ñ' | 'ò' | 'ó' | 'ô' | 'õ' | 'ö' | '÷' | 'ø' | 'ù' | 'ú' | 'û' | 'ü' | 'ý' | 'þ' | 'ÿ') [(-\U0010ffff]))> */
		nil,
		/* 37 mlLiteralString <- <('\'' '\'' '\'' <mlLiteralBody> ('\'' '\'' '\'') Action23)> */
		nil,
		/* 38 mlLiteralBody <- <(!('\'' '\'' '\'') (mlLiteralChar / newline))*> */
		nil,
		/* 39 mlLiteralChar <- <('\t' / [ -\U0010ffff])> */
		nil,
		/* 40 hexdigit <- <((&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))> */
		func() bool {
			position284, tokenIndex284 := position, tokenIndex
			{
				position285 := position
				{
					switch buffer[position] {
					case 'a', 'b', 'c', 'd', 'e', 'f':
						if c := buffer[position]; c < rune('a') || c > rune('f') {
							goto l284
						}
						position++
					case 'A', 'B', 'C', 'D', 'E', 'F':
						if c := buffer[position]; c < rune('A') || c > rune('F') {
							goto l284
						}
						position++
					default:
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l284
						}
						position++
					}
				}

				add(rulehexdigit, position285)
			}
			return true
		l284:
			position, tokenIndex = position284, tokenIndex284
			return false
		},
		/* 41 hexQuad <- <(hexdigit hexdigit hexdigit hexdigit)> */
		func() bool {
			position287, tokenIndex287 := position, tokenIndex
			{
				position288 := position
				if !_rules[rulehexdigit]() {
					goto l287
				}
				if !_rules[rulehexdigit]() {
					goto l287
				}
				if !_rules[rulehexdigit]() {
					goto l287
				}
				if !_rules[rulehexdigit]() {
					goto l287
				}
				add(rulehexQuad, position288)
			}
			return true
		l287:
			position, tokenIndex = position287, tokenIndex287
			return false
		},
		/* 42 boolean <- <(('t' 'r' 'u' 'e') / ('f' 'a' 'l' 's' 'e'))> */
		nil,
		/* 43 dateFullYear <- <digitQuad> */
		nil,
		/* 44 dateMonth <- <digitDual> */
		nil,
		/* 45 dateMDay <- <digitDual> */
		nil,
		/* 46 timeHour <- <digitDual> */
		func() bool {
			position293, tokenIndex293 := position, tokenIndex
			{
				position294 := position
				if !_rules[ruledigitDual]() {
					goto l293
				}
				add(ruletimeHour, position294)
			}
			return true
		l293:
			position, tokenIndex = position293, tokenIndex293
			return false
		},
		/* 47 timeMinute <- <digitDual> */
		func() bool {
			position295, tokenIndex295 := position, tokenIndex
			{
				position296 := position
				if !_rules[ruledigitDual]() {
					goto l295
				}
				add(ruletimeMinute, position296)
			}
			return true
		l295:
			position, tokenIndex = position295, tokenIndex295
			return false
		},
		/* 48 timeSecond <- <digitDual> */
		nil,
		/* 49 timeSecfrac <- <('.' digit+)> */
		nil,
		/* 50 timeNumoffset <- <(('-' / '+') timeHour ':' timeMinute)> */
		nil,
		/* 51 timeOffset <- <('Z' / timeNumoffset)> */
		nil,
		/* 52 partialTime <- <(timeHour ':' timeMinute ':' timeSecond timeSecfrac?)> */
		func() bool {
			position301, tokenIndex301 := position, tokenIndex
			{
				position302 := position
				if !_rules[ruletimeHour]() {
					goto l301
				}
				if buffer[position] != rune(':') {
					goto l301
				}
				position++
				if !_rules[ruletimeMinute]() {
					goto l301
				}
				if buffer[position] != rune(':') {
					goto l301
				}
				position++
				{
					position303 := position
					if !_rules[ruledigitDual]() {
						goto l301
					}
					add(ruletimeSecond, position303)
				}
				{
					position304, tokenIndex304 := position, tokenIndex
					{
						position306 := position
						if buffer[position] != rune('.') {
							goto l304
						}
						position++
						if !_rules[ruledigit]() {
							goto l304
						}
					l307:
						{
							position308, tokenIndex308 := position, tokenIndex
							if !_rules[ruledigit]() {
								goto l308
							}
							goto l307
						l308:
							position, tokenIndex = position308, tokenIndex308
						}
						add(ruletimeSecfrac, position306)
					}
					goto l305
				l304:
					position, tokenIndex = position304, tokenIndex304
				}
			l305:
				add(rulepartialTime, position302)
			}
			return true
		l301:
			position, tokenIndex = position301, tokenIndex301
			return false
		},
		/* 53 fullDate <- <(dateFullYear '-' dateMonth '-' dateMDay)> */
		nil,
		/* 54 fullTime <- <(partialTime timeOffset?)> */
		nil,
		/* 55 datetime <- <((fullDate ('T' fullTime)?) / partialTime)> */
		nil,
		/* 56 digit <- <[0-9]> */
		func() bool {
			position312, tokenIndex312 := position, tokenIndex
			{
				position313 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l312
				}
				position++
				add(ruledigit, position313)
			}
			return true
		l312:
			position, tokenIndex = position312, tokenIndex312
			return false
		},
		/* 57 digitDual <- <(digit digit)> */
		func() bool {
			position314, tokenIndex314 := position, tokenIndex
			{
				position315 := position
				if !_rules[ruledigit]() {
					goto l314
				}
				if !_rules[ruledigit]() {
					goto l314
				}
				add(ruledigitDual, position315)
			}
			return true
		l314:
			position, tokenIndex = position314, tokenIndex314
			return false
		},
		/* 58 digitQuad <- <(digitDual digitDual)> */
		nil,
		/* 59 array <- <('[' Action24 wsnl arrayValues? wsnl ']')> */
		nil,
		/* 60 arrayValues <- <(val Action25 (wsnl comment? wsnl arraySep wsnl comment? wsnl val Action26)* wsnl arraySep? wsnl comment?)> */
		nil,
		/* 61 arraySep <- <','> */
		func() bool {
			position319, tokenIndex319 := position, tokenIndex
			{
				position320 := position
				if buffer[position] != rune(',') {
					goto l319
				}
				position++
				add(rulearraySep, position320)
			}
			return true
		l319:
			position, tokenIndex = position319, tokenIndex319
			return false
		},
		/* 63 Action0 <- <{ _ = buffer }> */
		nil,
		nil,
		/* 65 Action1 <- <{ p.SetTableString(begin, end) }> */
		nil,
		/* 66 Action2 <- <{ p.AddLineCount((end - begin)/2) }> */
		nil,
		/* 67 Action3 <- <{ p.AddLineCount(end - begin) }> */
		nil,
		/* 68 Action4 <- <{ p.AddLineCount(1) }> */
		nil,
		/* 69 Action5 <- <{ p.AddKeyValue() }> */
		nil,
		/* 70 Action6 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 71 Action7 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 72 Action8 <- <{ p.SetTime(begin, end) }> */
		nil,
		/* 73 Action9 <- <{ p.SetFloat64(begin, end) }> */
		nil,
		/* 74 Action10 <- <{ p.SetInt64(begin, end) }> */
		nil,
		/* 75 Action11 <- <{ p.SetString(begin, end) }> */
		nil,
		/* 76 Action12 <- <{ p.SetBool(begin, end) }> */
		nil,
		/* 77 Action13 <- <{ p.SetArray(begin, end) }> */
		nil,
		/* 78 Action14 <- <{ p.SetTable(p.buffer, begin, end) }> */
		nil,
		/* 79 Action15 <- <{ p.SetArrayTable(p.buffer, begin, end) }> */
		nil,
		/* 80 Action16 <- <{ p.StartInlineTable() }> */
		nil,
		/* 81 Action17 <- <{ p.EndInlineTable() }> */
		nil,
		/* 82 Action18 <- <{ p.AddTableKey() }> */
		nil,
		/* 83 Action19 <- <{ p.SetBasicString(p.buffer, begin, end) }> */
		nil,
		/* 84 Action20 <- <{ p.SetMultilineString() }> */
		nil,
		/* 85 Action21 <- <{ p.AddMultilineBasicBody(p.buffer, begin, end) }> */
		nil,
		/* 86 Action22 <- <{ p.SetLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 87 Action23 <- <{ p.SetMultilineLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 88 Action24 <- <{ p.StartArray() }> */
		nil,
		/* 89 Action25 <- <{ p.AddArrayVal() }> */
		nil,
		/* 90 Action26 <- <{ p.AddArrayVal() }> */
		nil,
	}
	p.rules = _rules
	return nil
}
